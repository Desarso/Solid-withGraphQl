"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizedExecutor = void 0;
const utils_1 = require("@graphql-tools/utils");
const graphql_1 = require("graphql");
const execute_js_1 = require("./execute.js");
const repeater_1 = require("@repeaterjs/repeater");
const value_or_promise_1 = require("value-or-promise");
function normalizedExecutor(args) {
    const operationAST = (0, graphql_1.getOperationAST)(args.document, args.operationName);
    if (operationAST == null) {
        throw new Error('Must provide an operation.');
    }
    if (operationAST.operation === 'subscription') {
        return new value_or_promise_1.ValueOrPromise(() => (0, execute_js_1.subscribe)(args))
            .then((result) => {
            if ((0, utils_1.isAsyncIterable)(result)) {
                return new repeater_1.Repeater(async (push, stop) => {
                    let stopped = false;
                    stop.then(() => {
                        stopped = true;
                    });
                    let err;
                    try {
                        for await (const value of result) {
                            if (stopped) {
                                break;
                            }
                            await push(value);
                        }
                    }
                    catch (e) {
                        err = e;
                    }
                    stop(err);
                });
            }
            return result;
        })
            .resolve();
    }
    return new value_or_promise_1.ValueOrPromise(() => (0, execute_js_1.execute)(args))
        .then((result) => {
        if ('initialResult' in result) {
            return new repeater_1.Repeater(async (push, stop) => {
                let stopped = false;
                stop.then(() => {
                    stopped = true;
                });
                let err;
                try {
                    await push(result.initialResult);
                    for await (const value of result.subsequentResults) {
                        if (stopped) {
                            break;
                        }
                        await push(value);
                    }
                }
                catch (e) {
                    err = e;
                }
                stop(err);
            });
        }
        return result;
    })
        .resolve();
}
exports.normalizedExecutor = normalizedExecutor;
